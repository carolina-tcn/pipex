Manejar redirecciones de archivos y el pipe entre los comandos

./pipex archivo1 comando1 comando2 archivo2
< archivo1 comando1 | comando2 > archivo2

funciones autorizadas: open, close, read, write,
malloc, free, perror,
strerror, access, dup, dup2,
execve, exit, fork, pipe,
unlink, wait, waitpid
• ft_printf and any equivalent
YOU coded

FD->is an int that identifies an open file of the process

1. abrir y redireccionar archivos 
    - abrir archivo 1 para lectura
    - abrir archivo 2 para escritura (crear o truncar si ya existe)

2. crear la funcion pipe() para crear una pipe, esto me dara dos fd uno para lectura y otro para escritura
3. fork y exec:
    Crea un proceso hijo con fork().
    En el proceso hijo, redirecciona stdin para leer de archivo1 y stdout para escribir en el extremo de escritura del pipe. Luego, ejecuta comando1.
    En el proceso padre, espera a que el proceso hijo termine.
    Crea otro proceso hijo con fork().
    En este nuevo proceso hijo, redirecciona stdin para leer del extremo de lectura del pipe y stdout para escribir en archivo2. Luego, ejecuta comando2.

4.Redirecciones:
Redirigir stdin de comando1 a archivo1.
Redirigir stdout de comando1 al extremo de escritura del pipe.
Redirigir stdin de comando2 al extremo de lectura del pipe.
Redirigir stdout de comando2 a archivo2.

Redirecciones:
	- primer proceso hijo para comando1
	- segundo proceso hijo para comando2
	- cerrar y esperar
	
Frequently encountered problems
[0] As for splitting your envp path, print out the result of your split and have a look. Add a / at the end for the path to work correctly.

[1] If you launch your program and it gets stuck without executing anything, most probably one end of the pipe has not been closed correctly. Until one end is open, the other will be waiting for input and its process will not finish.

[2] Use perror("Error") to debug, especially right after fork() or execve(), to see what is going on in the pipe. Inside the pipe, everything done goes to one of its ends. printf for ex. won’t print to the terminal or it will print to your outfile (because we swapped the stdout); perror("Error") will work because it prints to stderr.

[3] Handle file rights when you open() them. Return error if the file cannot be opened, read or written. Check how the shell treats infile and outfile when they do not exist, are not readable, writable etc. (chmod is your best friend).
